diff --git a/subprojects/gst-libav/ext/libav/gstavdemux.c b/subprojects/gst-libav/ext/libav/gstavdemux.c
index ab6ac1b5c944..f07e7d3ffdf1 100644
--- a/subprojects/gst-libav/ext/libav/gstavdemux.c
+++ b/subprojects/gst-libav/ext/libav/gstavdemux.c
@@ -1372,63 +1372,6 @@ beach:
   }
 }
 
-#define GST_FFMPEG_TYPE_FIND_SIZE 4096
-#define GST_FFMPEG_TYPE_FIND_MIN_SIZE 256
-
-static void
-gst_ffmpegdemux_type_find (GstTypeFind * tf, gpointer priv)
-{
-  const guint8 *data;
-  AVInputFormat *in_plugin = (AVInputFormat *) priv;
-  gint res = 0;
-  guint64 length;
-  GstCaps *sinkcaps;
-
-  /* We want GST_FFMPEG_TYPE_FIND_SIZE bytes, but if the file is shorter than
-   * that we'll give it a try... */
-  length = gst_type_find_get_length (tf);
-  if (length == 0 || length > GST_FFMPEG_TYPE_FIND_SIZE)
-    length = GST_FFMPEG_TYPE_FIND_SIZE;
-
-  /* The ffmpeg typefinders assume there's a certain minimum amount of data
-   * and will happily do invalid memory access if there isn't, so let's just
-   * skip the ffmpeg typefinders if the data available is too short
-   * (in which case it's unlikely to be a media file anyway) */
-  if (length < GST_FFMPEG_TYPE_FIND_MIN_SIZE) {
-    GST_LOG ("not typefinding %" G_GUINT64_FORMAT " bytes, too short", length);
-    return;
-  }
-
-  GST_LOG ("typefinding %" G_GUINT64_FORMAT " bytes", length);
-  if (in_plugin->read_probe &&
-      (data = gst_type_find_peek (tf, 0, length)) != NULL) {
-    AVProbeData probe_data;
-
-    probe_data.filename = "";
-    probe_data.buf = (guint8 *) data;
-    probe_data.buf_size = length;
-
-    res = in_plugin->read_probe (&probe_data);
-    if (res > 0) {
-      res = MAX (1, res * GST_TYPE_FIND_MAXIMUM / AVPROBE_SCORE_MAX);
-      /* Restrict the probability for MPEG-TS streams, because there is
-       * probably a better version in plugins-base, if the user has a recent
-       * plugins-base (in fact we shouldn't even get here for ffmpeg mpegts or
-       * mpegtsraw typefinders, since we blacklist them) */
-      if (g_str_has_prefix (in_plugin->name, "mpegts"))
-        res = MIN (res, GST_TYPE_FIND_POSSIBLE);
-
-      sinkcaps = gst_ffmpeg_formatid_to_caps (in_plugin->name);
-
-      GST_LOG ("libav typefinder '%s' suggests %" GST_PTR_FORMAT ", p=%u%%",
-          in_plugin->name, sinkcaps, res);
-
-      gst_type_find_suggest (tf, res, sinkcaps);
-      gst_caps_unref (sinkcaps);
-    }
-  }
-}
-
 /* Task */
 static void
 gst_ffmpegdemux_loop (GstFFMpegDemux * demux)
@@ -2055,7 +1998,6 @@ gst_ffmpegdemux_register (GstPlugin * plugin)
   while ((in_plugin = av_demuxer_iterate (&i))) {
     gchar *type_name, *typefind_name;
     gint rank;
-    gboolean register_typefind_func = TRUE;
 
     GST_LOG ("Attempting to handle libav demuxer plugin %s [%s]",
         in_plugin->name, in_plugin->long_name);
@@ -2102,42 +2044,6 @@ gst_ffmpegdemux_register (GstPlugin * plugin)
         !strcmp (in_plugin->name, "ffmetadata"))
       continue;
 
-    /* Don't use the typefind functions of formats for which we already have
-     * better typefind functions */
-    if (!strcmp (in_plugin->name, "mov,mp4,m4a,3gp,3g2,mj2") ||
-        !strcmp (in_plugin->name, "ass") ||
-        !strcmp (in_plugin->name, "avi") ||
-        !strcmp (in_plugin->name, "asf") ||
-        !strcmp (in_plugin->name, "mpegvideo") ||
-        !strcmp (in_plugin->name, "mp3") ||
-        !strcmp (in_plugin->name, "matroska") ||
-        !strcmp (in_plugin->name, "matroska_webm") ||
-        !strcmp (in_plugin->name, "matroska,webm") ||
-        !strcmp (in_plugin->name, "mpeg") ||
-        !strcmp (in_plugin->name, "wav") ||
-        !strcmp (in_plugin->name, "au") ||
-        !strcmp (in_plugin->name, "tta") ||
-        !strcmp (in_plugin->name, "rm") ||
-        !strcmp (in_plugin->name, "amr") ||
-        !strcmp (in_plugin->name, "ogg") ||
-        !strcmp (in_plugin->name, "aiff") ||
-        !strcmp (in_plugin->name, "ape") ||
-        !strcmp (in_plugin->name, "dv") ||
-        !strcmp (in_plugin->name, "flv") ||
-        !strcmp (in_plugin->name, "mpc") ||
-        !strcmp (in_plugin->name, "mpc8") ||
-        !strcmp (in_plugin->name, "mpegts") ||
-        !strcmp (in_plugin->name, "mpegtsraw") ||
-        !strcmp (in_plugin->name, "mxf") ||
-        !strcmp (in_plugin->name, "nuv") ||
-        !strcmp (in_plugin->name, "swf") ||
-        !strcmp (in_plugin->name, "voc") ||
-        !strcmp (in_plugin->name, "pva") ||
-        !strcmp (in_plugin->name, "gif") ||
-        !strcmp (in_plugin->name, "vc1test") ||
-        !strcmp (in_plugin->name, "ivf"))
-      register_typefind_func = FALSE;
-
     /* Set the rank of demuxers known to work to MARGINAL.
      * Set demuxers for which we already have another implementation to NONE
      * Set All others to NONE*/
@@ -2214,11 +2120,7 @@ gst_ffmpegdemux_register (GstPlugin * plugin)
     else
       extensions = NULL;
 
-    if (!gst_element_register (plugin, type_name, rank, type) ||
-        (register_typefind_func == TRUE &&
-            !gst_type_find_register (plugin, typefind_name, rank,
-                gst_ffmpegdemux_type_find, extensions, NULL,
-                (gpointer) in_plugin, NULL))) {
+    if (!gst_element_register (plugin, type_name, rank, type)) {
       g_warning ("Registration of type %s failed", type_name);
       g_free (type_name);
       g_free (typefind_name);
-- 
diff --git a/subprojects/gst-libav/ext/libav/gstavprotocol.c b/subprojects/gst-libav/ext/libav/gstavprotocol.c
index 249b24064275..cb607d301299 100644
--- a/subprojects/gst-libav/ext/libav/gstavprotocol.c
+++ b/subprojects/gst-libav/ext/libav/gstavprotocol.c
@@ -102,7 +102,11 @@ gst_ffmpegdata_read (void *priv_data, unsigned char *buf, int size)
 }
 
 static int
+#if LIBAVUTIL_VERSION_MAJOR >= 59
+gst_ffmpegdata_write (void *priv_data, const uint8_t * buf, int size)
+#else
 gst_ffmpegdata_write (void *priv_data, uint8_t * buf, int size)
+#endif
 {
   GstProtocolInfo *info;
   GstBuffer *outbuf;
-- 
diff --git a/subprojects/gst-libav/ext/libav/gstavviddec.c b/subprojects/gst-libav/ext/libav/gstavviddec.c
index fe1ea51aa61b..576e96ee2a9c 100644
--- a/subprojects/gst-libav/ext/libav/gstavviddec.c
+++ b/subprojects/gst-libav/ext/libav/gstavviddec.c
@@ -1839,15 +1839,24 @@ not_negotiated:
  */
 static gboolean
 gst_ffmpegviddec_video_frame (GstFFMpegVidDec * ffmpegdec,
-    GstVideoCodecFrame * frame, GstFlowReturn * ret)
+    GstVideoCodecFrame * input_frame, GstFlowReturn * ret)
 {
   gint res;
   gboolean got_frame = FALSE;
   gboolean mode_switch;
-  GstVideoCodecFrame *out_frame;
+  GstVideoCodecFrame *output_frame;
   GstFFMpegVidDecVideoFrame *out_dframe;
   GstBufferPool *pool;
 
+  if (G_UNLIKELY (ffmpegdec->context->codec == NULL))
+    goto no_codec;
+
+#if LIBAVCODEC_VERSION_MAJOR >= 60
+  ffmpegdec->context->frame_num++;
+#else
+  ffmpegdec->context->frame_number++;
+#endif
+
   *ret = GST_FLOW_OK;
 
   /* in case we skip frames */
@@ -1855,7 +1864,7 @@ gst_ffmpegviddec_video_frame (GstFFMpegVidDec * ffmpegdec,
 
   /* run QoS code, we don't stop decoding the frame when we are late because
    * else we might skip a reference frame */
-  gst_ffmpegviddec_do_qos (ffmpegdec, frame, &mode_switch);
+  gst_ffmpegviddec_do_qos (ffmpegdec, input_frame, &mode_switch);
 
   /* FFmpeg might request new buffer from other threads.
    * Release lock here */
@@ -1882,17 +1891,17 @@ gst_ffmpegviddec_video_frame (GstFFMpegVidDec * ffmpegdec,
   /* get the output picture timing info again */
   out_dframe = ffmpegdec->picture->opaque;
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT (60, 31, 100)
-  out_frame =
+  output_frame =
       gst_video_codec_frame_ref (av_buffer_get_opaque (ffmpegdec->
           picture->opaque_ref));
 #else
   g_assert (out_dframe);
-  out_frame = gst_video_codec_frame_ref (out_dframe->frame);
+  output_frame = gst_video_codec_frame_ref (out_dframe->frame);
 #endif
 
   /* also give back a buffer allocated by the frame, if any */
   if (out_dframe) {
-    gst_buffer_replace (&out_frame->output_buffer, out_dframe->buffer);
+    gst_buffer_replace (&output_frame->output_buffer, out_dframe->buffer);
     gst_buffer_replace (&out_dframe->buffer, NULL);
   }
 
@@ -1923,7 +1932,7 @@ gst_ffmpegviddec_video_frame (GstFFMpegVidDec * ffmpegdec,
 
   GST_DEBUG_OBJECT (ffmpegdec,
       "pts %" G_GUINT64_FORMAT " duration %" G_GUINT64_FORMAT,
-      out_frame->pts, out_frame->duration);
+      output_frame->pts, output_frame->duration);
   GST_DEBUG_OBJECT (ffmpegdec, "picture: pts %" G_GUINT64_FORMAT,
       (guint64) ffmpegdec->picture->pts);
 #if LIBAVUTIL_VERSION_MAJOR < 58
@@ -1947,21 +1956,22 @@ gst_ffmpegviddec_video_frame (GstFFMpegVidDec * ffmpegdec,
       !!(ffmpegdec->picture->flags & AV_FRAME_FLAG_CORRUPT));
 
   if (!gst_ffmpegviddec_negotiate (ffmpegdec, ffmpegdec->context,
-          ffmpegdec->picture, GST_BUFFER_FLAGS (out_frame->input_buffer)))
+          ffmpegdec->picture, GST_BUFFER_FLAGS (output_frame->input_buffer)))
     goto negotiation_error;
 
   pool = gst_video_decoder_get_buffer_pool (GST_VIDEO_DECODER (ffmpegdec));
-  if (G_UNLIKELY (out_frame->output_buffer == NULL)) {
-    *ret = get_output_buffer (ffmpegdec, out_frame);
-  } else if (G_UNLIKELY (out_frame->output_buffer->pool != pool)) {
-    GstBuffer *tmp = out_frame->output_buffer;
-    out_frame->output_buffer = NULL;
-    *ret = get_output_buffer (ffmpegdec, out_frame);
+  if (G_UNLIKELY (output_frame->output_buffer == NULL)) {
+    *ret = get_output_buffer (ffmpegdec, output_frame);
+  } else if (G_UNLIKELY (output_frame->output_buffer->pool != pool)) {
+    GstBuffer *tmp = output_frame->output_buffer;
+    output_frame->output_buffer = NULL;
+    *ret = get_output_buffer (ffmpegdec, output_frame);
     gst_buffer_unref (tmp);
   }
 #ifndef G_DISABLE_ASSERT
   else {
-    GstVideoMeta *vmeta = gst_buffer_get_video_meta (out_frame->output_buffer);
+    GstVideoMeta *vmeta =
+        gst_buffer_get_video_meta (output_frame->output_buffer);
     if (vmeta) {
       GstVideoInfo *info = &ffmpegdec->output_state->info;
       g_assert ((gint) vmeta->width == GST_VIDEO_INFO_WIDTH (info));
@@ -1976,24 +1986,27 @@ gst_ffmpegviddec_video_frame (GstFFMpegVidDec * ffmpegdec,
 
   /* Mark corrupted frames as corrupted */
   if (ffmpegdec->picture->flags & AV_FRAME_FLAG_CORRUPT)
-    GST_BUFFER_FLAG_SET (out_frame->output_buffer, GST_BUFFER_FLAG_CORRUPTED);
+    GST_BUFFER_FLAG_SET (output_frame->output_buffer,
+        GST_BUFFER_FLAG_CORRUPTED);
 
   if (ffmpegdec->pic_interlaced) {
     /* set interlaced flags */
     if (ffmpegdec->picture->repeat_pict)
-      GST_BUFFER_FLAG_SET (out_frame->output_buffer, GST_VIDEO_BUFFER_FLAG_RFF);
+      GST_BUFFER_FLAG_SET (output_frame->output_buffer,
+          GST_VIDEO_BUFFER_FLAG_RFF);
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(60, 31, 100)
     if (ffmpegdec->picture->flags & AV_FRAME_FLAG_TOP_FIELD_FIRST)
 #else
     if (ffmpegdec->picture->top_field_first)
 #endif
-      GST_BUFFER_FLAG_SET (out_frame->output_buffer, GST_VIDEO_BUFFER_FLAG_TFF);
+      GST_BUFFER_FLAG_SET (output_frame->output_buffer,
+          GST_VIDEO_BUFFER_FLAG_TFF);
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(60, 31, 100)
     if (ffmpegdec->picture->flags & AV_FRAME_FLAG_INTERLACED)
 #else
     if (ffmpegdec->picture->interlaced_frame)
 #endif
-      GST_BUFFER_FLAG_SET (out_frame->output_buffer,
+      GST_BUFFER_FLAG_SET (output_frame->output_buffer,
           GST_VIDEO_BUFFER_FLAG_INTERLACED);
   }
 
@@ -2007,11 +2020,11 @@ gst_ffmpegviddec_video_frame (GstFFMpegVidDec * ffmpegdec,
       GST_MEMDUMP ("A53 CC", side_data->data, side_data->size);
 
       /* do not add closed caption meta if it already exists */
-      if (!gst_buffer_get_meta (out_frame->input_buffer,
+      if (!gst_buffer_get_meta (output_frame->input_buffer,
               GST_VIDEO_CAPTION_META_API_TYPE)) {
-        out_frame->output_buffer =
-            gst_buffer_make_writable (out_frame->output_buffer);
-        gst_buffer_add_video_caption_meta (out_frame->output_buffer,
+        output_frame->output_buffer =
+            gst_buffer_make_writable (output_frame->output_buffer);
+        gst_buffer_add_video_caption_meta (output_frame->output_buffer,
             GST_VIDEO_CAPTION_TYPE_CEA708_RAW, side_data->data,
             side_data->size);
       } else {
@@ -2037,7 +2050,7 @@ gst_ffmpegviddec_video_frame (GstFFMpegVidDec * ffmpegdec,
     while (l) {
       GstVideoCodecFrame *tmp = l->data;
 
-      if (tmp == out_frame)
+      if (tmp == output_frame)
         old = FALSE;
 
       if (old && GST_VIDEO_CODEC_FRAME_IS_DECODE_ONLY (tmp)) {
@@ -2060,28 +2073,30 @@ gst_ffmpegviddec_video_frame (GstFFMpegVidDec * ffmpegdec,
 
   av_frame_unref (ffmpegdec->picture);
 
-  if (frame)
-    GST_VIDEO_CODEC_FRAME_FLAG_UNSET (frame,
+  if (input_frame)
+    GST_VIDEO_CODEC_FRAME_FLAG_UNSET (input_frame,
         GST_FFMPEG_VIDEO_CODEC_FRAME_FLAG_ALLOCATED);
 
   if (gst_video_decoder_get_subframe_mode (GST_VIDEO_DECODER (ffmpegdec)))
     gst_video_decoder_have_last_subframe (GST_VIDEO_DECODER (ffmpegdec),
-        out_frame);
+        output_frame);
 
   /* FIXME: Ideally we would remap the buffer read-only now before pushing but
    * libav might still have a reference to it!
    */
-  if (GST_BUFFER_FLAG_IS_SET (out_frame->input_buffer,
+  if (GST_BUFFER_FLAG_IS_SET (output_frame->input_buffer,
           GST_VIDEO_BUFFER_FLAG_ONEFIELD)) {
-    GST_BUFFER_FLAG_SET (out_frame->output_buffer,
+    GST_BUFFER_FLAG_SET (output_frame->output_buffer,
         GST_VIDEO_BUFFER_FLAG_ONEFIELD);
-    if (GST_BUFFER_FLAG_IS_SET (out_frame->input_buffer,
+    if (GST_BUFFER_FLAG_IS_SET (output_frame->input_buffer,
             GST_VIDEO_BUFFER_FLAG_TFF)) {
-      GST_BUFFER_FLAG_SET (out_frame->output_buffer, GST_VIDEO_BUFFER_FLAG_TFF);
+      GST_BUFFER_FLAG_SET (output_frame->output_buffer,
+          GST_VIDEO_BUFFER_FLAG_TFF);
     }
   }
   *ret =
-      gst_video_decoder_finish_frame (GST_VIDEO_DECODER (ffmpegdec), out_frame);
+      gst_video_decoder_finish_frame (GST_VIDEO_DECODER (ffmpegdec),
+      output_frame);
 
 beach:
   GST_DEBUG_OBJECT (ffmpegdec, "return flow %s, got frame: %d",
@@ -2092,15 +2107,15 @@ beach:
 no_output:
   {
     GST_DEBUG_OBJECT (ffmpegdec, "no output buffer");
-    GST_VIDEO_CODEC_FRAME_FLAG_UNSET (frame,
+    GST_VIDEO_CODEC_FRAME_FLAG_UNSET (input_frame,
         GST_FFMPEG_VIDEO_CODEC_FRAME_FLAG_ALLOCATED);
-    gst_video_decoder_drop_frame (GST_VIDEO_DECODER (ffmpegdec), out_frame);
+    gst_video_decoder_drop_frame (GST_VIDEO_DECODER (ffmpegdec), output_frame);
     goto beach;
   }
 
 negotiation_error:
   {
-    gst_video_decoder_drop_frame (GST_VIDEO_DECODER (ffmpegdec), out_frame);
+    gst_video_decoder_drop_frame (GST_VIDEO_DECODER (ffmpegdec), output_frame);
     if (GST_PAD_IS_FLUSHING (GST_VIDEO_DECODER_SRC_PAD (ffmpegdec))) {
       *ret = GST_FLOW_FLUSHING;
       goto beach;
@@ -2109,39 +2124,16 @@ negotiation_error:
     *ret = GST_FLOW_NOT_NEGOTIATED;
     goto beach;
   }
-}
-
-
- /* Returns: Whether a frame was decoded */
-static gboolean
-gst_ffmpegviddec_frame (GstFFMpegVidDec * ffmpegdec, GstVideoCodecFrame * frame,
-    GstFlowReturn * ret)
-{
-  gboolean got_frame = FALSE;
 
-  if (G_UNLIKELY (ffmpegdec->context->codec == NULL))
-    goto no_codec;
-
-  *ret = GST_FLOW_OK;
-#if LIBAVCODEC_VERSION_MAJOR >= 60
-  ffmpegdec->context->frame_num++;
-#else
-  ffmpegdec->context->frame_number++;
-#endif
-
-  got_frame = gst_ffmpegviddec_video_frame (ffmpegdec, frame, ret);
-
-  return got_frame;
-
-  /* ERRORS */
 no_codec:
   {
     GST_ERROR_OBJECT (ffmpegdec, "no codec context");
     *ret = GST_FLOW_NOT_NEGOTIATED;
-    return -1;
+    goto beach;
   }
 }
 
+
 static GstFlowReturn
 gst_ffmpegviddec_drain (GstVideoDecoder * decoder)
 {
@@ -2160,7 +2152,7 @@ gst_ffmpegviddec_drain (GstVideoDecoder * decoder)
   GST_VIDEO_DECODER_STREAM_LOCK (ffmpegdec);
 
   do {
-    got_frame = gst_ffmpegviddec_frame (ffmpegdec, NULL, &ret);
+    got_frame = gst_ffmpegviddec_video_frame (ffmpegdec, NULL, &ret);
   } while (got_frame && ret == GST_FLOW_OK);
 
   GST_VIDEO_DECODER_STREAM_UNLOCK (ffmpegdec);
@@ -2285,7 +2277,7 @@ gst_ffmpegviddec_handle_frame (GstVideoDecoder * decoder,
 
   do {
     /* decode a frame of audio/video now */
-    got_frame = gst_ffmpegviddec_frame (ffmpegdec, frame, &ret);
+    got_frame = gst_ffmpegviddec_video_frame (ffmpegdec, frame, &ret);
 
     if (ret != GST_FLOW_OK) {
       GST_LOG_OBJECT (ffmpegdec, "breaking because of flow ret %s",
-- 
diff --git a/subprojects/gst-libav/ext/libav/gstav.c b/subprojects/gst-libav/ext/libav/gstav.c
index 00fcc6388137..0c9353f0c157 100644
--- a/subprojects/gst-libav/ext/libav/gstav.c
+++ b/subprojects/gst-libav/ext/libav/gstav.c
@@ -72,18 +72,6 @@ gst_ffmpeg_avcodec_open (AVCodecContext * avctx, const AVCodec * codec)
   return ret;
 }
 
-int
-gst_ffmpeg_avcodec_close (AVCodecContext * avctx)
-{
-  int ret;
-
-  g_mutex_lock (&gst_avcodec_mutex);
-  ret = avcodec_close (avctx);
-  g_mutex_unlock (&gst_avcodec_mutex);
-
-  return ret;
-}
-
 int
 gst_ffmpeg_av_find_stream_info (AVFormatContext * ic)
 {
diff --git a/subprojects/gst-libav/ext/libav/gstav.h b/subprojects/gst-libav/ext/libav/gstav.h
index a7fbb019fd55..9cdb14503c3a 100644
--- a/subprojects/gst-libav/ext/libav/gstav.h
+++ b/subprojects/gst-libav/ext/libav/gstav.h
@@ -46,7 +46,6 @@ extern gboolean gst_ffmpegdeinterlace_register (GstPlugin * plugin);
 extern gboolean gst_ffmpegvidcmp_register (GstPlugin * plugin);
 
 int gst_ffmpeg_avcodec_open (AVCodecContext *avctx, const AVCodec *codec);
-int gst_ffmpeg_avcodec_close (AVCodecContext *avctx);
 int gst_ffmpeg_av_find_stream_info(AVFormatContext *ic);
 
 G_END_DECLS
diff --git a/subprojects/gst-libav/ext/libav/gstavauddec.c b/subprojects/gst-libav/ext/libav/gstavauddec.c
index 48c4be6b6a14..2279e690ee5e 100644
--- a/subprojects/gst-libav/ext/libav/gstavauddec.c
+++ b/subprojects/gst-libav/ext/libav/gstavauddec.c
@@ -145,16 +145,6 @@ gst_ffmpegauddec_class_init (GstFFMpegAudDecClass * klass)
 static void
 gst_ffmpegauddec_init (GstFFMpegAudDec * ffmpegdec)
 {
-  GstFFMpegAudDecClass *klass =
-      (GstFFMpegAudDecClass *) G_OBJECT_GET_CLASS (ffmpegdec);
-
-  /* some ffmpeg data */
-  ffmpegdec->context = avcodec_alloc_context3 (klass->in_plugin);
-  ffmpegdec->context->opaque = ffmpegdec;
-  ffmpegdec->opened = FALSE;
-
-  ffmpegdec->frame = av_frame_alloc ();
-
   GST_PAD_SET_ACCEPT_TEMPLATE (GST_AUDIO_DECODER_SINK_PAD (ffmpegdec));
   gst_audio_decoder_set_use_default_pad_acceptcaps (GST_AUDIO_DECODER_CAST
       (ffmpegdec), TRUE);
@@ -175,60 +165,24 @@ gst_ffmpegauddec_finalize (GObject * object)
 }
 
 /* With LOCK */
-static gboolean
-gst_ffmpegauddec_close (GstFFMpegAudDec * ffmpegdec, gboolean reset)
+static void
+gst_ffmpegauddec_close (GstFFMpegAudDec * ffmpegdec)
 {
-  GstFFMpegAudDecClass *oclass;
-
-  oclass = (GstFFMpegAudDecClass *) (G_OBJECT_GET_CLASS (ffmpegdec));
-
   GST_LOG_OBJECT (ffmpegdec, "closing libav codec");
 
   gst_caps_replace (&ffmpegdec->last_caps, NULL);
-
-  gst_ffmpeg_avcodec_close (ffmpegdec->context);
-  ffmpegdec->opened = FALSE;
-
   av_freep (&ffmpegdec->context->extradata);
-
-  if (reset) {
-    avcodec_free_context (&ffmpegdec->context);
-    ffmpegdec->context = avcodec_alloc_context3 (oclass->in_plugin);
-    if (ffmpegdec->context == NULL) {
-      GST_DEBUG_OBJECT (ffmpegdec, "Failed to set context defaults");
-      return FALSE;
-    }
-    ffmpegdec->context->opaque = ffmpegdec;
-  }
-
-  return TRUE;
+  avcodec_free_context (&ffmpegdec->context);
 }
 
 static gboolean
 gst_ffmpegauddec_start (GstAudioDecoder * decoder)
 {
   GstFFMpegAudDec *ffmpegdec = (GstFFMpegAudDec *) decoder;
-  GstFFMpegAudDecClass *oclass;
-
-  oclass = (GstFFMpegAudDecClass *) (G_OBJECT_GET_CLASS (ffmpegdec));
 
   GST_OBJECT_LOCK (ffmpegdec);
+  ffmpegdec->frame = av_frame_alloc ();
   avcodec_free_context (&ffmpegdec->context);
-  ffmpegdec->context = avcodec_alloc_context3 (oclass->in_plugin);
-  if (ffmpegdec->context == NULL) {
-    GST_DEBUG_OBJECT (ffmpegdec, "Failed to set context defaults");
-    GST_OBJECT_UNLOCK (ffmpegdec);
-    return FALSE;
-  }
-  ffmpegdec->context->opaque = ffmpegdec;
-
-  /* FIXME: https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/1474 */
-  if ((oclass->in_plugin->capabilities & AV_CODEC_CAP_DELAY) != 0
-      && (oclass->in_plugin->id == AV_CODEC_ID_WMAV1
-          || oclass->in_plugin->id == AV_CODEC_ID_WMAV2)) {
-    ffmpegdec->context->flags2 |= AV_CODEC_FLAG2_SKIP_MANUAL;
-  }
-
   GST_OBJECT_UNLOCK (ffmpegdec);
 
   return TRUE;
@@ -240,8 +194,9 @@ gst_ffmpegauddec_stop (GstAudioDecoder * decoder)
   GstFFMpegAudDec *ffmpegdec = (GstFFMpegAudDec *) decoder;
 
   GST_OBJECT_LOCK (ffmpegdec);
-  gst_ffmpegauddec_close (ffmpegdec, FALSE);
+  av_frame_free (&ffmpegdec->frame);
   g_free (ffmpegdec->padded);
+  gst_ffmpegauddec_close (ffmpegdec);
   ffmpegdec->padded = NULL;
   ffmpegdec->padded_size = 0;
   GST_OBJECT_UNLOCK (ffmpegdec);
@@ -262,8 +217,6 @@ gst_ffmpegauddec_open (GstFFMpegAudDec * ffmpegdec)
   if (gst_ffmpeg_avcodec_open (ffmpegdec->context, oclass->in_plugin) < 0)
     goto could_not_open;
 
-  ffmpegdec->opened = TRUE;
-
   GST_LOG_OBJECT (ffmpegdec, "Opened libav codec %s, id %d",
       oclass->in_plugin->name, oclass->in_plugin->id);
 
@@ -274,7 +227,7 @@ gst_ffmpegauddec_open (GstFFMpegAudDec * ffmpegdec)
   /* ERRORS */
 could_not_open:
   {
-    gst_ffmpegauddec_close (ffmpegdec, TRUE);
+    gst_ffmpegauddec_close (ffmpegdec);
     GST_DEBUG_OBJECT (ffmpegdec, "avdec_%s: Failed to open libav codec",
         oclass->in_plugin->name);
     return FALSE;
@@ -321,14 +274,26 @@ gst_ffmpegauddec_set_format (GstAudioDecoder * decoder, GstCaps * caps)
   gst_caps_replace (&ffmpegdec->last_caps, caps);
 
   /* close old session */
-  if (ffmpegdec->opened) {
+  if (ffmpegdec->context) {
     GST_OBJECT_UNLOCK (ffmpegdec);
     gst_ffmpegauddec_drain (ffmpegdec, FALSE);
     GST_OBJECT_LOCK (ffmpegdec);
-    if (!gst_ffmpegauddec_close (ffmpegdec, TRUE)) {
-      GST_OBJECT_UNLOCK (ffmpegdec);
-      return FALSE;
-    }
+    gst_ffmpegauddec_close (ffmpegdec);
+  }
+
+  ffmpegdec->context = avcodec_alloc_context3 (oclass->in_plugin);
+  if (ffmpegdec->context == NULL) {
+    GST_DEBUG_OBJECT (ffmpegdec, "Failed to allocate context");
+    GST_OBJECT_UNLOCK (ffmpegdec);
+    return FALSE;
+  }
+  ffmpegdec->context->opaque = ffmpegdec;
+
+  /* FIXME: https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/1474 */
+  if ((oclass->in_plugin->capabilities & AV_CODEC_CAP_DELAY) != 0
+      && (oclass->in_plugin->id == AV_CODEC_ID_WMAV1
+          || oclass->in_plugin->id == AV_CODEC_ID_WMAV2)) {
+    ffmpegdec->context->flags2 |= AV_CODEC_FLAG2_SKIP_MANUAL;
   }
 
   /* get size and so */
@@ -586,7 +551,7 @@ gst_ffmpegauddec_frame (GstFFMpegAudDec * ffmpegdec, GstFlowReturn * ret,
   GstBuffer *outbuf = NULL;
   gboolean got_frame = FALSE;
 
-  if (G_UNLIKELY (ffmpegdec->context->codec == NULL))
+  if (G_UNLIKELY (!ffmpegdec->context))
     goto no_codec;
 
   *ret = GST_FLOW_OK;
@@ -630,6 +595,9 @@ gst_ffmpegauddec_drain (GstFFMpegAudDec * ffmpegdec, gboolean force)
   gboolean need_more_data = FALSE;
   gboolean got_frame;
 
+  if (!ffmpegdec->context)
+    return GST_FLOW_OK;
+
   if (avcodec_send_packet (ffmpegdec->context, NULL))
     goto send_packet_failed;
 
@@ -672,7 +640,7 @@ gst_ffmpegauddec_flush (GstAudioDecoder * decoder, gboolean hard)
 {
   GstFFMpegAudDec *ffmpegdec = (GstFFMpegAudDec *) decoder;
 
-  if (ffmpegdec->opened) {
+  if (ffmpegdec->context) {
     avcodec_flush_buffers (ffmpegdec->context);
   }
 }
@@ -697,7 +665,7 @@ gst_ffmpegauddec_handle_frame (GstAudioDecoder * decoder, GstBuffer * inbuf)
 
   ffmpegdec = (GstFFMpegAudDec *) decoder;
 
-  if (G_UNLIKELY (!ffmpegdec->opened))
+  if (G_UNLIKELY (!ffmpegdec->context))
     goto not_negotiated;
 
   if (inbuf == NULL) {
diff --git a/subprojects/gst-libav/ext/libav/gstavauddec.h b/subprojects/gst-libav/ext/libav/gstavauddec.h
index d91de0d2b29e..93466ad99fb4 100644
--- a/subprojects/gst-libav/ext/libav/gstavauddec.h
+++ b/subprojects/gst-libav/ext/libav/gstavauddec.h
@@ -34,7 +34,6 @@ struct _GstFFMpegAudDec
 
   /* decoding */
   AVCodecContext *context;
-  gboolean opened;
 
   AVFrame *frame;
 
diff --git a/subprojects/gst-libav/ext/libav/gstavaudenc.c b/subprojects/gst-libav/ext/libav/gstavaudenc.c
index 57f41fe617d0..6ff966d32cee 100644
--- a/subprojects/gst-libav/ext/libav/gstavaudenc.c
+++ b/subprojects/gst-libav/ext/libav/gstavaudenc.c
@@ -161,10 +161,7 @@ gst_ffmpegaudenc_init (GstFFMpegAudEnc * ffmpegaudenc)
   GST_PAD_SET_ACCEPT_TEMPLATE (GST_AUDIO_ENCODER_SINK_PAD (ffmpegaudenc));
 
   /* ffmpeg objects */
-  ffmpegaudenc->context = avcodec_alloc_context3 (klass->in_plugin);
   ffmpegaudenc->refcontext = avcodec_alloc_context3 (klass->in_plugin);
-  ffmpegaudenc->opened = FALSE;
-  ffmpegaudenc->frame = av_frame_alloc ();
 
   gst_audio_encoder_set_drainable (GST_AUDIO_ENCODER (ffmpegaudenc), TRUE);
 }
@@ -186,18 +183,12 @@ static gboolean
 gst_ffmpegaudenc_start (GstAudioEncoder * encoder)
 {
   GstFFMpegAudEnc *ffmpegaudenc = (GstFFMpegAudEnc *) encoder;
-  GstFFMpegAudEncClass *oclass =
-      (GstFFMpegAudEncClass *) G_OBJECT_GET_CLASS (ffmpegaudenc);
 
-  ffmpegaudenc->opened = FALSE;
+  avcodec_free_context (&ffmpegaudenc->context);
+  av_frame_free (&ffmpegaudenc->frame);
   ffmpegaudenc->need_reopen = FALSE;
 
-  avcodec_free_context (&ffmpegaudenc->context);
-  ffmpegaudenc->context = avcodec_alloc_context3 (oclass->in_plugin);
-  if (ffmpegaudenc->context == NULL) {
-    GST_DEBUG_OBJECT (ffmpegaudenc, "Failed to set context defaults");
-    return FALSE;
-  }
+  ffmpegaudenc->frame = av_frame_alloc ();
 
   return TRUE;
 }
@@ -208,8 +199,8 @@ gst_ffmpegaudenc_stop (GstAudioEncoder * encoder)
   GstFFMpegAudEnc *ffmpegaudenc = (GstFFMpegAudEnc *) encoder;
 
   /* close old session */
-  gst_ffmpeg_avcodec_close (ffmpegaudenc->context);
-  ffmpegaudenc->opened = FALSE;
+  avcodec_free_context (&ffmpegaudenc->context);
+  av_frame_free (&ffmpegaudenc->frame);
   ffmpegaudenc->need_reopen = FALSE;
 
   return TRUE;
@@ -220,7 +211,7 @@ gst_ffmpegaudenc_flush (GstAudioEncoder * encoder)
 {
   GstFFMpegAudEnc *ffmpegaudenc = (GstFFMpegAudEnc *) encoder;
 
-  if (ffmpegaudenc->opened) {
+  if (ffmpegaudenc->context) {
     avcodec_flush_buffers (ffmpegaudenc->context);
   }
 }
@@ -239,14 +230,11 @@ gst_ffmpegaudenc_set_format (GstAudioEncoder * encoder, GstAudioInfo * info)
   ffmpegaudenc->need_reopen = FALSE;
 
   /* close old session */
-  if (ffmpegaudenc->opened) {
-    avcodec_free_context (&ffmpegaudenc->context);
-    ffmpegaudenc->opened = FALSE;
-    ffmpegaudenc->context = avcodec_alloc_context3 (oclass->in_plugin);
-    if (ffmpegaudenc->context == NULL) {
-      GST_DEBUG_OBJECT (ffmpegaudenc, "Failed to set context defaults");
-      return FALSE;
-    }
+  avcodec_free_context (&ffmpegaudenc->context);
+  ffmpegaudenc->context = avcodec_alloc_context3 (oclass->in_plugin);
+  if (ffmpegaudenc->context == NULL) {
+    GST_DEBUG_OBJECT (ffmpegaudenc, "Failed to set context defaults");
+    return FALSE;
   }
 
   gst_ffmpeg_cfg_fill_context (G_OBJECT (ffmpegaudenc), ffmpegaudenc->context);
@@ -298,12 +286,8 @@ gst_ffmpegaudenc_set_format (GstAudioEncoder * encoder, GstAudioInfo * info)
   /* open codec */
   if (gst_ffmpeg_avcodec_open (ffmpegaudenc->context, oclass->in_plugin) < 0) {
     gst_caps_unref (allowed_caps);
-    avcodec_free_context (&ffmpegaudenc->context);
     GST_DEBUG_OBJECT (ffmpegaudenc, "avenc_%s: Failed to open FFMPEG codec",
         oclass->in_plugin->name);
-    ffmpegaudenc->context = avcodec_alloc_context3 (oclass->in_plugin);
-    if (ffmpegaudenc->context == NULL)
-      GST_DEBUG_OBJECT (ffmpegaudenc, "Failed to set context defaults");
 
     if ((oclass->in_plugin->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&
         ffmpegaudenc->context->strict_std_compliance !=
@@ -315,6 +299,7 @@ gst_ffmpegaudenc_set_format (GstAudioEncoder * encoder, GstAudioInfo * info)
               "or of good quality. If you must use it anyway, set the "
               "compliance property to experimental"));
     }
+    avcodec_free_context (&ffmpegaudenc->context);
     return FALSE;
   }
 
@@ -326,9 +311,6 @@ gst_ffmpegaudenc_set_format (GstAudioEncoder * encoder, GstAudioInfo * info)
     gst_caps_unref (allowed_caps);
     avcodec_free_context (&ffmpegaudenc->context);
     GST_DEBUG ("Unsupported codec - no caps found");
-    ffmpegaudenc->context = avcodec_alloc_context3 (oclass->in_plugin);
-    if (ffmpegaudenc->context == NULL)
-      GST_DEBUG_OBJECT (ffmpegaudenc, "Failed to set context defaults");
     return FALSE;
   }
 
@@ -337,6 +319,7 @@ gst_ffmpegaudenc_set_format (GstAudioEncoder * encoder, GstAudioInfo * info)
   gst_caps_unref (other_caps);
   if (gst_caps_is_empty (icaps)) {
     gst_caps_unref (icaps);
+    avcodec_free_context (&ffmpegaudenc->context);
     return FALSE;
   }
   icaps = gst_caps_fixate (icaps);
@@ -345,9 +328,6 @@ gst_ffmpegaudenc_set_format (GstAudioEncoder * encoder, GstAudioInfo * info)
           icaps)) {
     avcodec_free_context (&ffmpegaudenc->context);
     gst_caps_unref (icaps);
-    ffmpegaudenc->context = avcodec_alloc_context3 (oclass->in_plugin);
-    if (ffmpegaudenc->context == NULL)
-      GST_DEBUG_OBJECT (ffmpegaudenc, "Failed to set context defaults");
     return FALSE;
   }
   gst_caps_unref (icaps);
@@ -385,8 +365,6 @@ gst_ffmpegaudenc_set_format (GstAudioEncoder * encoder, GstAudioInfo * info)
   }
 
   /* success! */
-  ffmpegaudenc->opened = TRUE;
-  ffmpegaudenc->need_reopen = FALSE;
 
   return TRUE;
 }
@@ -394,8 +372,7 @@ gst_ffmpegaudenc_set_format (GstAudioEncoder * encoder, GstAudioInfo * info)
 static void
 gst_ffmpegaudenc_free_avpacket (gpointer pkt)
 {
-  av_packet_unref ((AVPacket *) pkt);
-  g_free (pkt);
+  av_packet_free ((AVPacket **) & pkt);
 }
 
 typedef struct
@@ -596,8 +573,7 @@ gst_ffmpegaudenc_receive_packet (GstFFMpegAudEnc * ffmpegaudenc,
 
   ctx = ffmpegaudenc->context;
 
-  pkt = g_new0 (AVPacket, 1);
-
+  pkt = av_packet_alloc ();
   res = avcodec_receive_packet (ctx, pkt);
 
   if (res == 0) {
@@ -636,7 +612,7 @@ gst_ffmpegaudenc_receive_packet (GstFFMpegAudEnc * ffmpegaudenc,
     *got_packet = TRUE;
   } else {
     GST_LOG_OBJECT (ffmpegaudenc, "no output produced");
-    g_free (pkt);
+    av_packet_free (&pkt);
     ret = GST_FLOW_OK;
     *got_packet = FALSE;
   }
@@ -650,6 +626,9 @@ gst_ffmpegaudenc_drain (GstFFMpegAudEnc * ffmpegaudenc)
   GstFlowReturn ret = GST_FLOW_OK;
   gboolean got_packet;
 
+  if (!ffmpegaudenc->context)
+    return GST_FLOW_OK;
+
   ret = gst_ffmpegaudenc_send_frame (ffmpegaudenc, NULL);
 
   if (ret == GST_FLOW_OK) {
@@ -683,7 +662,7 @@ gst_ffmpegaudenc_handle_frame (GstAudioEncoder * encoder, GstBuffer * inbuf)
 
   ffmpegaudenc = (GstFFMpegAudEnc *) encoder;
 
-  if (G_UNLIKELY (!ffmpegaudenc->opened))
+  if (G_UNLIKELY (!ffmpegaudenc->context))
     goto not_negotiated;
 
   if (!inbuf)
@@ -752,7 +731,7 @@ gst_ffmpegaudenc_set_property (GObject * object,
 
   ffmpegaudenc = (GstFFMpegAudEnc *) (object);
 
-  if (ffmpegaudenc->opened) {
+  if (ffmpegaudenc->context) {
     GST_WARNING_OBJECT (ffmpegaudenc,
         "Can't change properties once encoder is setup !");
     return;
diff --git a/subprojects/gst-libav/ext/libav/gstavaudenc.h b/subprojects/gst-libav/ext/libav/gstavaudenc.h
index 3c94aef4e061..e21de8337d6b 100644
--- a/subprojects/gst-libav/ext/libav/gstavaudenc.h
+++ b/subprojects/gst-libav/ext/libav/gstavaudenc.h
@@ -38,7 +38,6 @@ struct _GstFFMpegAudEnc
 
   AVCodecContext *context;
   AVCodecContext *refcontext;
-  gboolean opened;
   gboolean need_reopen;
 
   AVFrame *frame;
diff --git a/subprojects/gst-libav/ext/libav/gstavcfg.c b/subprojects/gst-libav/ext/libav/gstavcfg.c
index bcc501c39cc8..6092b086c474 100644
--- a/subprojects/gst-libav/ext/libav/gstavcfg.c
+++ b/subprojects/gst-libav/ext/libav/gstavcfg.c
@@ -488,10 +488,8 @@ gst_ffmpeg_cfg_install_properties (GObjectClass * klass, AVCodec * in_plugin,
       install_opts ((GObjectClass *) klass, &ctx->av_class, prop_id, flags,
       " (Generic codec option, might have no effect)", generic_overrides);
 
-  if (ctx) {
-    gst_ffmpeg_avcodec_close (ctx);
-    av_free (ctx);
-  }
+  if (ctx)
+    avcodec_free_context (&ctx);
 }
 
 static gint
diff --git a/subprojects/gst-libav/ext/libav/gstavdeinterlace.c b/subprojects/gst-libav/ext/libav/gstavdeinterlace.c
index 2d46c5090185..49dcdffb492f 100644
--- a/subprojects/gst-libav/ext/libav/gstavdeinterlace.c
+++ b/subprojects/gst-libav/ext/libav/gstavdeinterlace.c
@@ -225,14 +225,13 @@ gst_ffmpegdeinterlace_sink_setcaps (GstPad * pad, GstObject * parent,
   ctx->pix_fmt = AV_PIX_FMT_NB;
   gst_ffmpeg_caps_with_codectype (AVMEDIA_TYPE_VIDEO, caps, ctx);
   if (ctx->pix_fmt == AV_PIX_FMT_NB) {
-    gst_ffmpeg_avcodec_close (ctx);
-    av_free (ctx);
+    avcodec_free_context (&ctx);
     return FALSE;
   }
 
   deinterlace->pixfmt = ctx->pix_fmt;
 
-  av_free (ctx);
+  avcodec_free_context (&ctx);
 
   deinterlace->to_size =
       av_image_get_buffer_size (deinterlace->pixfmt, deinterlace->width,
diff --git a/subprojects/gst-libav/ext/libav/gstavviddec.c b/subprojects/gst-libav/ext/libav/gstavviddec.c
index 576e96ee2a9c..f131e99c94c9 100644
--- a/subprojects/gst-libav/ext/libav/gstavviddec.c
+++ b/subprojects/gst-libav/ext/libav/gstavviddec.c
@@ -337,14 +337,7 @@ gst_ffmpegviddec_init (GstFFMpegVidDec * ffmpegdec)
 static void
 gst_ffmpegviddec_subinit (GstFFMpegVidDec * ffmpegdec)
 {
-  GstFFMpegVidDecClass *klass =
-      (GstFFMpegVidDecClass *) G_OBJECT_GET_CLASS (ffmpegdec);
-
   /* some ffmpeg data */
-  ffmpegdec->context = avcodec_alloc_context3 (klass->in_plugin);
-  ffmpegdec->context->opaque = ffmpegdec;
-  ffmpegdec->picture = av_frame_alloc ();
-  ffmpegdec->opened = FALSE;
   ffmpegdec->skip_frame = ffmpegdec->lowres = 0;
   ffmpegdec->direct_rendering = DEFAULT_DIRECT_RENDERING;
   ffmpegdec->max_threads = DEFAULT_MAX_THREADS;
@@ -365,6 +358,8 @@ gst_ffmpegviddec_finalize (GObject * object)
   GstFFMpegVidDec *ffmpegdec = GST_FFMPEGVIDDEC (object);
 
   av_frame_free (&ffmpegdec->picture);
+  if (ffmpegdec->context)
+    av_freep (&ffmpegdec->context->extradata);
   avcodec_free_context (&ffmpegdec->context);
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
@@ -395,37 +390,23 @@ gst_ffmpegviddec_context_set_flags2 (AVCodecContext * context, guint flags,
 }
 
 /* with LOCK */
-static gboolean
-gst_ffmpegviddec_close (GstFFMpegVidDec * ffmpegdec, gboolean reset)
+static void
+gst_ffmpegviddec_close (GstFFMpegVidDec * ffmpegdec)
 {
-  GstFFMpegVidDecClass *oclass;
   guint i;
 
-  oclass = GST_FFMPEGVIDDEC_GET_CLASS (ffmpegdec);
-
   GST_LOG_OBJECT (ffmpegdec, "closing ffmpeg codec");
 
   gst_caps_replace (&ffmpegdec->last_caps, NULL);
 
-  gst_ffmpeg_avcodec_close (ffmpegdec->context);
-  ffmpegdec->opened = FALSE;
+  if (ffmpegdec->context)
+    av_freep (&ffmpegdec->context->extradata);
+  avcodec_free_context (&ffmpegdec->context);
 
   for (i = 0; i < G_N_ELEMENTS (ffmpegdec->stride); i++)
     ffmpegdec->stride[i] = -1;
 
   gst_buffer_replace (&ffmpegdec->palette, NULL);
-
-  av_freep (&ffmpegdec->context->extradata);
-  if (reset) {
-    avcodec_free_context (&ffmpegdec->context);
-    ffmpegdec->context = avcodec_alloc_context3 (oclass->in_plugin);
-    if (ffmpegdec->context == NULL) {
-      GST_DEBUG_OBJECT (ffmpegdec, "Failed to set context defaults");
-      return FALSE;
-    }
-    ffmpegdec->context->opaque = ffmpegdec;
-  }
-  return TRUE;
 }
 
 /* with LOCK */
@@ -443,8 +424,6 @@ gst_ffmpegviddec_open (GstFFMpegVidDec * ffmpegdec)
   for (i = 0; i < G_N_ELEMENTS (ffmpegdec->stride); i++)
     ffmpegdec->stride[i] = -1;
 
-  ffmpegdec->opened = TRUE;
-
   GST_LOG_OBJECT (ffmpegdec, "Opened libav codec %s, id %d",
       oclass->in_plugin->name, oclass->in_plugin->id);
 
@@ -460,7 +439,7 @@ gst_ffmpegviddec_open (GstFFMpegVidDec * ffmpegdec)
   /* ERRORS */
 could_not_open:
   {
-    gst_ffmpegviddec_close (ffmpegdec, TRUE);
+    gst_ffmpegviddec_close (ffmpegdec);
     GST_DEBUG_OBJECT (ffmpegdec, "avdec_%s: Failed to open libav codec",
         oclass->in_plugin->name);
     return FALSE;
@@ -537,14 +516,11 @@ gst_ffmpegviddec_set_format (GstVideoDecoder * decoder,
   }
 
   /* close old session */
-  if (ffmpegdec->opened) {
+  if (ffmpegdec->context) {
     GST_OBJECT_UNLOCK (ffmpegdec);
     gst_ffmpegviddec_finish (decoder);
     GST_OBJECT_LOCK (ffmpegdec);
-    if (!gst_ffmpegviddec_close (ffmpegdec, TRUE)) {
-      GST_OBJECT_UNLOCK (ffmpegdec);
-      return FALSE;
-    }
+    gst_ffmpegviddec_close (ffmpegdec);
     ffmpegdec->pic_pix_fmt = 0;
     ffmpegdec->pic_width = 0;
     ffmpegdec->pic_height = 0;
@@ -560,6 +536,14 @@ gst_ffmpegviddec_set_format (GstVideoDecoder * decoder,
     ffmpegdec->cur_multiview_flags = GST_VIDEO_MULTIVIEW_FLAGS_NONE;
   }
 
+  ffmpegdec->context = avcodec_alloc_context3 (oclass->in_plugin);
+  if (ffmpegdec->context == NULL) {
+    GST_DEBUG_OBJECT (ffmpegdec, "Failed to allocate context");
+    GST_OBJECT_UNLOCK (ffmpegdec);
+    return FALSE;
+  }
+  ffmpegdec->context->opaque = ffmpegdec;
+
   gst_caps_replace (&ffmpegdec->last_caps, state->caps);
 
   /* set buffer functions */
@@ -718,12 +702,18 @@ done:
 open_failed:
   {
     GST_DEBUG_OBJECT (ffmpegdec, "Failed to open");
+    if (ffmpegdec->context)
+      av_freep (&ffmpegdec->context->extradata);
+    avcodec_free_context (&ffmpegdec->context);
     goto done;
   }
 nal_only_slice:
   {
     GST_ERROR_OBJECT (ffmpegdec,
         "Can't do NAL aligned H.264 with frame threading.");
+    if (ffmpegdec->context)
+      av_freep (&ffmpegdec->context->extradata);
+    avcodec_free_context (&ffmpegdec->context);
     goto done;
   }
 }
@@ -1848,7 +1838,7 @@ gst_ffmpegviddec_video_frame (GstFFMpegVidDec * ffmpegdec,
   GstFFMpegVidDecVideoFrame *out_dframe;
   GstBufferPool *pool;
 
-  if (G_UNLIKELY (ffmpegdec->context->codec == NULL))
+  if (G_UNLIKELY (!ffmpegdec->context))
     goto no_codec;
 
 #if LIBAVCODEC_VERSION_MAJOR >= 60
@@ -2141,7 +2131,7 @@ gst_ffmpegviddec_drain (GstVideoDecoder * decoder)
   GstFlowReturn ret = GST_FLOW_OK;
   gboolean got_frame = FALSE;
 
-  if (!ffmpegdec->opened)
+  if (!ffmpegdec->context)
     return GST_FLOW_OK;
 
   GST_VIDEO_DECODER_STREAM_UNLOCK (ffmpegdec);
@@ -2187,6 +2177,12 @@ gst_ffmpegviddec_handle_frame (GstVideoDecoder * decoder,
   GstFlowReturn ret = GST_FLOW_OK;
   AVPacket *packet;
 
+  if (G_UNLIKELY (!ffmpegdec->context)) {
+    gst_video_codec_frame_unref (frame);
+    GST_ERROR_OBJECT (ffmpegdec, "no codec context");
+    return GST_FLOW_NOT_NEGOTIATED;
+  }
+
   GST_LOG_OBJECT (ffmpegdec,
       "Received new data of size %" G_GSIZE_FORMAT ", dts %" GST_TIME_FORMAT
       ", pts:%" GST_TIME_FORMAT ", dur:%" GST_TIME_FORMAT,
@@ -2196,6 +2192,7 @@ gst_ffmpegviddec_handle_frame (GstVideoDecoder * decoder,
   if (!gst_buffer_map (frame->input_buffer, &minfo, GST_MAP_READ)) {
     GST_ELEMENT_ERROR (ffmpegdec, STREAM, DECODE, ("Decoding problem"),
         ("Failed to map buffer for reading"));
+    gst_video_codec_frame_unref (frame);
     return GST_FLOW_ERROR;
   }
 
@@ -2304,19 +2301,13 @@ static gboolean
 gst_ffmpegviddec_start (GstVideoDecoder * decoder)
 {
   GstFFMpegVidDec *ffmpegdec = GST_FFMPEGVIDDEC (decoder);
-  GstFFMpegVidDecClass *oclass;
-
-  oclass = GST_FFMPEGVIDDEC_GET_CLASS (ffmpegdec);
 
   GST_OBJECT_LOCK (ffmpegdec);
+  av_frame_free (&ffmpegdec->picture);
+  if (ffmpegdec->context)
+    av_freep (&ffmpegdec->context->extradata);
   avcodec_free_context (&ffmpegdec->context);
-  ffmpegdec->context = avcodec_alloc_context3 (oclass->in_plugin);
-  if (ffmpegdec->context == NULL) {
-    GST_DEBUG_OBJECT (ffmpegdec, "Failed to set context defaults");
-    GST_OBJECT_UNLOCK (ffmpegdec);
-    return FALSE;
-  }
-  ffmpegdec->context->opaque = ffmpegdec;
+  ffmpegdec->picture = av_frame_alloc ();
   GST_OBJECT_UNLOCK (ffmpegdec);
 
   return TRUE;
@@ -2328,7 +2319,8 @@ gst_ffmpegviddec_stop (GstVideoDecoder * decoder)
   GstFFMpegVidDec *ffmpegdec = GST_FFMPEGVIDDEC (decoder);
 
   GST_OBJECT_LOCK (ffmpegdec);
-  gst_ffmpegviddec_close (ffmpegdec, FALSE);
+  av_frame_free (&ffmpegdec->picture);
+  gst_ffmpegviddec_close (ffmpegdec);
   GST_OBJECT_UNLOCK (ffmpegdec);
   g_free (ffmpegdec->padded);
   ffmpegdec->padded = NULL;
@@ -2382,7 +2374,7 @@ gst_ffmpegviddec_flush (GstVideoDecoder * decoder)
 {
   GstFFMpegVidDec *ffmpegdec = GST_FFMPEGVIDDEC (decoder);
 
-  if (ffmpegdec->opened) {
+  if (ffmpegdec->context) {
     GST_LOG_OBJECT (decoder, "flushing buffers");
     GST_VIDEO_DECODER_STREAM_UNLOCK (ffmpegdec);
     avcodec_flush_buffers (ffmpegdec->context);
@@ -2571,11 +2563,10 @@ gst_ffmpegviddec_set_property (GObject * object,
 
   switch (prop_id) {
     case PROP_LOWRES:
-      ffmpegdec->lowres = ffmpegdec->context->lowres = g_value_get_enum (value);
+      ffmpegdec->lowres = g_value_get_enum (value);
       break;
     case PROP_SKIPFRAME:
-      ffmpegdec->skip_frame = ffmpegdec->context->skip_frame =
-          g_value_get_enum (value);
+      ffmpegdec->skip_frame = g_value_get_enum (value);
       break;
     case PROP_DIRECT_RENDERING:
       ffmpegdec->direct_rendering = g_value_get_boolean (value);
diff --git a/subprojects/gst-libav/ext/libav/gstavviddec.h b/subprojects/gst-libav/ext/libav/gstavviddec.h
index 0f713de5691c..14d5a9aff352 100644
--- a/subprojects/gst-libav/ext/libav/gstavviddec.h
+++ b/subprojects/gst-libav/ext/libav/gstavviddec.h
@@ -54,7 +54,6 @@ struct _GstFFMpegVidDec
   GstVideoMultiviewMode picture_multiview_mode;
   GstVideoMultiviewFlags picture_multiview_flags;
   gint stride[AV_NUM_DATA_POINTERS];
-  gboolean opened;
 
   /* current output pictures */
   enum AVPixelFormat pic_pix_fmt;
diff --git a/subprojects/gst-libav/ext/libav/gstavvidenc.c b/subprojects/gst-libav/ext/libav/gstavvidenc.c
index 461263b4f645..78694c303f72 100644
--- a/subprojects/gst-libav/ext/libav/gstavvidenc.c
+++ b/subprojects/gst-libav/ext/libav/gstavvidenc.c
@@ -208,10 +208,7 @@ gst_ffmpegvidenc_init (GstFFMpegVidEnc * ffmpegenc)
 
   GST_PAD_SET_ACCEPT_TEMPLATE (GST_VIDEO_ENCODER_SINK_PAD (ffmpegenc));
 
-  ffmpegenc->context = avcodec_alloc_context3 (klass->in_plugin);
   ffmpegenc->refcontext = avcodec_alloc_context3 (klass->in_plugin);
-  ffmpegenc->picture = av_frame_alloc ();
-  ffmpegenc->opened = FALSE;
   ffmpegenc->file = NULL;
 }
 
@@ -222,10 +219,8 @@ gst_ffmpegvidenc_finalize (GObject * object)
 
   /* clean up remaining allocated data */
   av_frame_free (&ffmpegenc->picture);
-  gst_ffmpeg_avcodec_close (ffmpegenc->context);
-  gst_ffmpeg_avcodec_close (ffmpegenc->refcontext);
-  av_freep (&ffmpegenc->context);
-  av_freep (&ffmpegenc->refcontext);
+  avcodec_free_context (&ffmpegenc->context);
+  avcodec_free_context (&ffmpegenc->refcontext);
   g_free (ffmpegenc->filename);
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
@@ -247,14 +242,11 @@ gst_ffmpegvidenc_set_format (GstVideoEncoder * encoder,
   ffmpegenc->need_reopen = FALSE;
 
   /* close old session */
-  if (ffmpegenc->opened) {
-    avcodec_free_context (&ffmpegenc->context);
-    ffmpegenc->opened = FALSE;
-    ffmpegenc->context = avcodec_alloc_context3 (oclass->in_plugin);
-    if (ffmpegenc->context == NULL) {
-      GST_DEBUG_OBJECT (ffmpegenc, "Failed to set context defaults");
-      return FALSE;
-    }
+  avcodec_free_context (&ffmpegenc->context);
+  ffmpegenc->context = avcodec_alloc_context3 (oclass->in_plugin);
+  if (ffmpegenc->context == NULL) {
+    GST_DEBUG_OBJECT (ffmpegenc, "Failed to allocate context");
+    return FALSE;
   }
 
   /* additional avcodec settings */
@@ -402,7 +394,6 @@ gst_ffmpegvidenc_set_format (GstVideoEncoder * encoder,
 
   /* success! */
   ffmpegenc->pts_offset = GST_CLOCK_TIME_NONE;
-  ffmpegenc->opened = TRUE;
 
   return TRUE;
 
@@ -412,6 +403,7 @@ open_file_err:
     GST_ELEMENT_ERROR (ffmpegenc, RESOURCE, OPEN_WRITE,
         (("Could not open file \"%s\" for writing."), ffmpegenc->filename),
         GST_ERROR_SYSTEM);
+    avcodec_free_context (&ffmpegenc->context);
     return FALSE;
   }
 file_read_err:
@@ -419,6 +411,7 @@ file_read_err:
     GST_ELEMENT_ERROR (ffmpegenc, RESOURCE, READ,
         (("Could not get contents of file \"%s\"."), ffmpegenc->filename),
         GST_ERROR_SYSTEM);
+    avcodec_free_context (&ffmpegenc->context);
     return FALSE;
   }
 
@@ -426,12 +419,12 @@ insane_timebase:
   {
     GST_ERROR_OBJECT (ffmpegenc, "Rejecting time base %d/%d",
         ffmpegenc->context->time_base.den, ffmpegenc->context->time_base.num);
-    goto cleanup_stats_in;
+    goto close_codec;
   }
 unsupported_codec:
   {
     GST_DEBUG ("Unsupported codec - no caps found");
-    goto cleanup_stats_in;
+    goto close_codec;
   }
 open_codec_fail:
   {
@@ -456,15 +449,13 @@ bad_input_fmt:
   }
 close_codec:
   {
+    if (ffmpegenc->context)
+      g_free (ffmpegenc->context->stats_in);
+    if (ffmpegenc->file) {
+      fclose (ffmpegenc->file);
+      ffmpegenc->file = NULL;
+    }
     avcodec_free_context (&ffmpegenc->context);
-    ffmpegenc->context = avcodec_alloc_context3 (oclass->in_plugin);
-    if (ffmpegenc->context == NULL)
-      GST_DEBUG_OBJECT (ffmpegenc, "Failed to set context defaults");
-    goto cleanup_stats_in;
-  }
-cleanup_stats_in:
-  {
-    g_free (ffmpegenc->context->stats_in);
     return FALSE;
   }
 }
@@ -483,8 +474,7 @@ gst_ffmpegvidenc_propose_allocation (GstVideoEncoder * encoder,
 static void
 gst_ffmpegvidenc_free_avpacket (gpointer pkt)
 {
-  av_packet_unref ((AVPacket *) pkt);
-  g_free (pkt);
+  av_packet_free ((AVPacket **) & pkt);
 }
 
 typedef struct
@@ -692,18 +682,18 @@ gst_ffmpegvidenc_receive_packet (GstFFMpegVidEnc * ffmpegenc,
 
   *got_packet = FALSE;
 
-  pkt = g_new0 (AVPacket, 1);
-
+  pkt = av_packet_alloc ();
   res = avcodec_receive_packet (ffmpegenc->context, pkt);
 
   if (res == AVERROR (EAGAIN)) {
-    g_free (pkt);
+    av_packet_free (&pkt);
     goto done;
   } else if (res == AVERROR_EOF) {
-    g_free (pkt);
+    av_packet_free (&pkt);
     ret = GST_FLOW_EOS;
     goto done;
   } else if (res < 0) {
+    av_packet_free (&pkt);
     ret = GST_FLOW_ERROR;
     goto done;
   }
@@ -767,7 +757,7 @@ gst_ffmpegvidenc_handle_frame (GstVideoEncoder * encoder,
   GstFlowReturn ret;
   gboolean got_packet;
 
-  /* endoder was drained or flushed, and ffmpeg encoder doesn't support
+  /* encoder was drained or flushed, and ffmpeg encoder doesn't support
    * flushing. We need to re-open encoder then */
   if (ffmpegenc->need_reopen) {
     gboolean reopen_ret;
@@ -778,6 +768,7 @@ gst_ffmpegvidenc_handle_frame (GstVideoEncoder * encoder,
     if (!ffmpegenc->input_state) {
       GST_ERROR_OBJECT (ffmpegenc,
           "Cannot re-open encoder without input state");
+      gst_video_codec_frame_unref (frame);
       return GST_FLOW_NOT_NEGOTIATED;
     }
 
@@ -787,6 +778,7 @@ gst_ffmpegvidenc_handle_frame (GstVideoEncoder * encoder,
 
     if (!reopen_ret) {
       GST_ERROR_OBJECT (ffmpegenc, "Couldn't re-open encoder");
+      gst_video_codec_frame_unref (frame);
       return GST_FLOW_NOT_NEGOTIATED;
     }
   }
@@ -831,7 +823,7 @@ gst_ffmpegvidenc_flush_buffers (GstFFMpegVidEnc * ffmpegenc, gboolean send)
   GST_DEBUG_OBJECT (ffmpegenc, "flushing buffers with sending %d", send);
 
   /* no need to empty codec if there is none */
-  if (!ffmpegenc->opened)
+  if (!ffmpegenc->context)
     goto done;
 
   ret = gst_ffmpegvidenc_send_frame (ffmpegenc, NULL);
@@ -867,7 +859,7 @@ gst_ffmpegvidenc_set_property (GObject * object,
 
   ffmpegenc = (GstFFMpegVidEnc *) (object);
 
-  if (ffmpegenc->opened) {
+  if (ffmpegenc->context) {
     GST_WARNING_OBJECT (ffmpegenc,
         "Can't change properties once decoder is setup !");
     return;
@@ -921,7 +913,7 @@ gst_ffmpegvidenc_flush (GstVideoEncoder * encoder)
 {
   GstFFMpegVidEnc *ffmpegenc = (GstFFMpegVidEnc *) encoder;
 
-  if (ffmpegenc->opened) {
+  if (ffmpegenc->context) {
     avcodec_flush_buffers (ffmpegenc->context);
     ffmpegenc->pts_offset = GST_CLOCK_TIME_NONE;
   }
@@ -933,20 +925,19 @@ static gboolean
 gst_ffmpegvidenc_start (GstVideoEncoder * encoder)
 {
   GstFFMpegVidEnc *ffmpegenc = (GstFFMpegVidEnc *) encoder;
-  GstFFMpegVidEncClass *oclass =
-      (GstFFMpegVidEncClass *) G_OBJECT_GET_CLASS (ffmpegenc);
-
-  ffmpegenc->opened = FALSE;
-  ffmpegenc->need_reopen = FALSE;
 
   /* close old session */
-  avcodec_free_context (&ffmpegenc->context);
-  ffmpegenc->context = avcodec_alloc_context3 (oclass->in_plugin);
-  if (ffmpegenc->context == NULL) {
-    GST_DEBUG_OBJECT (ffmpegenc, "Failed to set context defaults");
-    return FALSE;
+  if (ffmpegenc->file) {
+    fclose (ffmpegenc->file);
+    ffmpegenc->file = NULL;
   }
+  if (ffmpegenc->context)
+    g_free (ffmpegenc->context->stats_in);
+  avcodec_free_context (&ffmpegenc->context);
+  av_frame_free (&ffmpegenc->picture);
+  ffmpegenc->need_reopen = FALSE;
 
+  ffmpegenc->picture = av_frame_alloc ();
   gst_video_encoder_set_min_pts (encoder, GST_SECOND * 60 * 60 * 1000);
 
   return TRUE;
@@ -958,8 +949,14 @@ gst_ffmpegvidenc_stop (GstVideoEncoder * encoder)
   GstFFMpegVidEnc *ffmpegenc = (GstFFMpegVidEnc *) encoder;
 
   gst_ffmpegvidenc_flush_buffers (ffmpegenc, FALSE);
-  gst_ffmpeg_avcodec_close (ffmpegenc->context);
-  ffmpegenc->opened = FALSE;
+  if (ffmpegenc->context)
+    g_free (ffmpegenc->context->stats_in);
+  if (ffmpegenc->file) {
+    fclose (ffmpegenc->file);
+    ffmpegenc->file = NULL;
+  }
+  avcodec_free_context (&ffmpegenc->context);
+  av_frame_free (&ffmpegenc->picture);
   ffmpegenc->need_reopen = FALSE;
 
   if (ffmpegenc->input_state) {
diff --git a/subprojects/gst-libav/ext/libav/gstavvidenc.h b/subprojects/gst-libav/ext/libav/gstavvidenc.h
index 340fb2520421..1e73c9ac57df 100644
--- a/subprojects/gst-libav/ext/libav/gstavvidenc.h
+++ b/subprojects/gst-libav/ext/libav/gstavvidenc.h
@@ -41,7 +41,6 @@ struct _GstFFMpegVidEnc
   AVCodecContext *context;
   AVFrame *picture;
   GstClockTime pts_offset;
-  gboolean opened;
   gboolean need_reopen;
   gboolean discont;
   guint pass;
-- 
diff --git a/subprojects/gst-libav/ext/libav/gstavdemux.c b/subprojects/gst-libav/ext/libav/gstavdemux.c
index f07e7d3ffdf1..2c68d622f1a8 100644
--- a/subprojects/gst-libav/ext/libav/gstavdemux.c
+++ b/subprojects/gst-libav/ext/libav/gstavdemux.c
@@ -67,7 +67,6 @@ struct _GstFFMpegDemux
   guint group_id;
 
   AVFormatContext *context;
-  gboolean opened;
 
   GstFFStream *streams[MAX_STREAMS];
 
@@ -273,7 +272,6 @@ gst_ffmpegdemux_init (GstFFMpegDemux * demux)
   demux->have_group_id = FALSE;
   demux->group_id = G_MAXUINT;
 
-  demux->opened = FALSE;
   demux->context = NULL;
 
   for (n = 0; n < MAX_STREAMS; n++) {
@@ -324,7 +322,7 @@ gst_ffmpegdemux_close (GstFFMpegDemux * demux)
   gint n;
   GstEvent **event_p;
 
-  if (!demux->opened)
+  if (!demux->context)
     return;
 
   /* remove pads from ourselves */
@@ -353,12 +351,8 @@ gst_ffmpegdemux_close (GstFFMpegDemux * demux)
     gst_ffmpeg_pipe_close (demux->context->pb);
   demux->context->pb = NULL;
   avformat_close_input (&demux->context);
-  if (demux->context)
-    avformat_free_context (demux->context);
-  demux->context = NULL;
 
   GST_OBJECT_LOCK (demux);
-  demux->opened = FALSE;
   event_p = &demux->seek_event;
   gst_event_replace (event_p, NULL);
   GST_OBJECT_UNLOCK (demux);
@@ -700,7 +694,7 @@ gst_ffmpegdemux_send_event (GstElement * element, GstEvent * event)
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_SEEK:
       GST_OBJECT_LOCK (demux);
-      if (!demux->opened) {
+      if (!demux->context) {
         GstEvent **event_p;
 
         GST_DEBUG_OBJECT (demux, "caching seek event");
@@ -1309,7 +1303,6 @@ gst_ffmpegdemux_open (GstFFMpegDemux * demux)
   demux->segment.duration = demux->duration;
 
   GST_OBJECT_LOCK (demux);
-  demux->opened = TRUE;
   event = demux->seek_event;
   demux->seek_event = NULL;
   cached_events = demux->cached_events;
@@ -1366,6 +1359,15 @@ gst_ffmpegdemux_open (GstFFMpegDemux * demux)
   /* ERRORS */
 beach:
   {
+    if (demux->context->pb) {
+      if (demux->seekable)
+        gst_ffmpegdata_close (demux->context->pb);
+      else
+        gst_ffmpeg_pipe_close (demux->context->pb);
+      demux->context->pb = NULL;
+    }
+    avformat_close_input (&demux->context);
+
     GST_ELEMENT_ERROR (demux, LIBRARY, FAILED, (NULL),
         ("%s", gst_ffmpegdemux_averror (res)));
     return FALSE;
@@ -1390,7 +1392,7 @@ gst_ffmpegdemux_loop (GstFFMpegDemux * demux)
   gint64 pts;
 
   /* open file if we didn't so already */
-  if (!demux->opened)
+  if (!demux->context)
     if (!gst_ffmpegdemux_open (demux))
       goto open_failed;
 
@@ -1725,7 +1727,7 @@ gst_ffmpegdemux_sink_event (GstPad * sinkpad, GstObject * parent,
        * If the demuxer isn't opened, push straight away, since we'll
        * be waiting against a cond that will never be signalled. */
       if (GST_EVENT_IS_SERIALIZED (event)) {
-        if (demux->opened) {
+        if (demux->context) {
           GST_FFMPEG_PIPE_MUTEX_LOCK (ffpipe);
           while (!ffpipe->needed)
             GST_FFMPEG_PIPE_WAIT (ffpipe);
diff --git a/subprojects/gst-libav/ext/libav/gstavmux.c b/subprojects/gst-libav/ext/libav/gstavmux.c
index 60da7f0c29e1..389a873cf717 100644
--- a/subprojects/gst-libav/ext/libav/gstavmux.c
+++ b/subprojects/gst-libav/ext/libav/gstavmux.c
@@ -796,6 +796,7 @@ gst_ffmpegmux_change_state (GstElement * element, GstStateChange transition)
       if (ffmpegmux->opened) {
         ffmpegmux->opened = FALSE;
         gst_ffmpegdata_close (ffmpegmux->context->pb);
+        ffmpegmux->context->pb = NULL;
       }
       break;
     case GST_STATE_CHANGE_READY_TO_NULL:
-- 
diff --git a/subprojects/gst-libav/ext/libav/gstavvidenc.c b/subprojects/gst-libav/ext/libav/gstavvidenc.c
index 78694c303f72..0d6e98723707 100644
--- a/subprojects/gst-libav/ext/libav/gstavvidenc.c
+++ b/subprojects/gst-libav/ext/libav/gstavvidenc.c
@@ -630,7 +630,9 @@ gst_ffmpegvidenc_send_frame (GstFFMpegVidEnc * ffmpegenc,
     picture->pts = AV_NOPTS_VALUE;
   } else {
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(60, 31, 100)
-    const gint ticks_per_frame = (ffmpegenc->context->codec_descriptor
+    const gint ticks_per_frame =
+        (GST_VIDEO_INFO_IS_INTERLACED (&ffmpegenc->input_state->info)
+        && ffmpegenc->context->codec_descriptor
         && ffmpegenc->context->
         codec_descriptor->props & AV_CODEC_PROP_FIELDS) ? 2 : 1;
 #else
-- 
diff --git a/subprojects/gst-libav/ext/libav/gstavvidenc.c b/subprojects/gst-libav/ext/libav/gstavvidenc.c
index 0d6e98723707..43c9f31c418c 100644
--- a/subprojects/gst-libav/ext/libav/gstavvidenc.c
+++ b/subprojects/gst-libav/ext/libav/gstavvidenc.c
@@ -735,7 +735,7 @@ gst_ffmpegvidenc_receive_packet (GstFFMpegVidEnc * ffmpegenc,
           ffmpegenc->context->time_base);
 
       if (gst_pts_dts_diff > frame->pts)
-        frame->pts = 0;
+        frame->dts = 0;
       else
         frame->dts = frame->pts - gst_pts_dts_diff;
     } else {
-- 
diff --git a/subprojects/gst-libav/ext/libav/gstavviddec.c b/subprojects/gst-libav/ext/libav/gstavviddec.c
index f131e99c94c9..fe51832d2350 100644
--- a/subprojects/gst-libav/ext/libav/gstavviddec.c
+++ b/subprojects/gst-libav/ext/libav/gstavviddec.c
@@ -670,7 +670,9 @@ update_state:
     const gint fps_n = ffmpegdec->context->time_base.den;
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(60, 31, 100)
     const gint ticks_per_frame =
-        (ffmpegdec->context->
+        (GST_VIDEO_INFO_IS_INTERLACED (&ffmpegdec->input_state->info)
+        && ffmpegdec->context->codec_descriptor
+        && ffmpegdec->context->
         codec_descriptor->props & AV_CODEC_PROP_FIELDS) ? 2 : 1;
 #else
     const gint ticks_per_frame = ffmpegdec->context->ticks_per_frame;
@@ -1155,8 +1157,11 @@ static gboolean
 context_changed (GstFFMpegVidDec * ffmpegdec, AVCodecContext * context)
 {
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(60, 31, 100)
-  const gint ticks_per_frame = (context->codec_descriptor
-      && context->codec_descriptor->props & AV_CODEC_PROP_FIELDS) ? 2 : 1;
+  const gint ticks_per_frame =
+      (GST_VIDEO_INFO_IS_INTERLACED (&ffmpegdec->input_state->info)
+      && ffmpegdec->context->codec_descriptor
+      && ffmpegdec->context->
+      codec_descriptor->props & AV_CODEC_PROP_FIELDS) ? 2 : 1;
 #else
   const gint ticks_per_frame = context->ticks_per_frame;
 #endif
@@ -1228,8 +1233,11 @@ update_video_context (GstFFMpegVidDec * ffmpegdec, AVCodecContext * context,
     ffmpegdec->pic_field_order_changed = FALSE;
 
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(60, 31, 100)
-  const gint ticks_per_frame = (context->codec_descriptor
-      && context->codec_descriptor->props & AV_CODEC_PROP_FIELDS) ? 2 : 1;
+  const gint ticks_per_frame =
+      (GST_VIDEO_INFO_IS_INTERLACED (&ffmpegdec->input_state->info)
+      && ffmpegdec->context->codec_descriptor
+      && ffmpegdec->context->
+      codec_descriptor->props & AV_CODEC_PROP_FIELDS) ? 2 : 1;
 #else
   const gint ticks_per_frame = context->ticks_per_frame;
 #endif
-- 
diff --git a/subprojects/gst-libav/ext/libav/gstavvidenc.c b/subprojects/gst-libav/ext/libav/gstavvidenc.c
index 43c9f31c418c..90c35d216dcf 100644
--- a/subprojects/gst-libav/ext/libav/gstavvidenc.c
+++ b/subprojects/gst-libav/ext/libav/gstavvidenc.c
@@ -248,6 +248,7 @@ gst_ffmpegvidenc_set_format (GstVideoEncoder * encoder,
     GST_DEBUG_OBJECT (ffmpegenc, "Failed to allocate context");
     return FALSE;
   }
+  ffmpegenc->last_pts_ff = G_MININT64;
 
   /* additional avcodec settings */
   gst_ffmpeg_cfg_fill_context (G_OBJECT (ffmpegenc), ffmpegenc->context);
@@ -550,6 +551,7 @@ gst_ffmpegvidenc_send_frame (GstFFMpegVidEnc * ffmpegenc,
   gint res;
   GstFlowReturn ret = GST_FLOW_ERROR;
   AVFrame *picture = NULL;
+  GstClockTime pts, pts_running_time;
 
   if (!frame)
     goto send_frame;
@@ -619,13 +621,21 @@ gst_ffmpegvidenc_send_frame (GstFFMpegVidEnc * ffmpegenc,
   picture->width = GST_VIDEO_FRAME_WIDTH (&buffer_info->vframe);
   picture->height = GST_VIDEO_FRAME_HEIGHT (&buffer_info->vframe);
 
+  // Use the running time to calculate a PTS that is passed to the encoder.
+  // This ensures that it is increasing even if there are segment changes and
+  // makes it unnecessary to drain the encoder on every segment change.
+  pts = frame->pts;
+  pts_running_time =
+      gst_segment_to_running_time (&GST_VIDEO_ENCODER
+      (ffmpegenc)->input_segment, GST_FORMAT_TIME, pts);
+
   if (ffmpegenc->pts_offset == GST_CLOCK_TIME_NONE) {
-    ffmpegenc->pts_offset = frame->pts;
+    ffmpegenc->pts_offset = pts_running_time;
   }
 
-  if (frame->pts == GST_CLOCK_TIME_NONE) {
+  if (pts_running_time == GST_CLOCK_TIME_NONE) {
     picture->pts = AV_NOPTS_VALUE;
-  } else if (frame->pts < ffmpegenc->pts_offset) {
+  } else if (pts_running_time < ffmpegenc->pts_offset) {
     GST_ERROR_OBJECT (ffmpegenc, "PTS is going backwards");
     picture->pts = AV_NOPTS_VALUE;
   } else {
@@ -639,8 +649,18 @@ gst_ffmpegvidenc_send_frame (GstFFMpegVidEnc * ffmpegenc,
     const gint ticks_per_frame = ffmpegenc->context->ticks_per_frame;
 #endif
     picture->pts =
-        gst_ffmpeg_time_gst_to_ff ((frame->pts - ffmpegenc->pts_offset) /
+        gst_ffmpeg_time_gst_to_ff ((pts_running_time - ffmpegenc->pts_offset) /
         ticks_per_frame, ffmpegenc->context->time_base);
+
+    // Certain codecs require always increasing PTS to work correctly. This
+    // affects at least all MPEG1/2/4 based encoders.
+    if (ffmpegenc->last_pts_ff == G_MININT64
+        || picture->pts > ffmpegenc->last_pts_ff) {
+      ffmpegenc->last_pts_ff = picture->pts;
+    } else {
+      ffmpegenc->last_pts_ff += 1;
+      picture->pts = ffmpegenc->last_pts_ff;
+    }
   }
 
 send_frame:
diff --git a/subprojects/gst-libav/ext/libav/gstavvidenc.h b/subprojects/gst-libav/ext/libav/gstavvidenc.h
index 1e73c9ac57df..3b1f2e848825 100644
--- a/subprojects/gst-libav/ext/libav/gstavvidenc.h
+++ b/subprojects/gst-libav/ext/libav/gstavvidenc.h
@@ -41,6 +41,7 @@ struct _GstFFMpegVidEnc
   AVCodecContext *context;
   AVFrame *picture;
   GstClockTime pts_offset;
+  gint64 last_pts_ff;
   gboolean need_reopen;
   gboolean discont;
   guint pass;
-- 
diff --git a/subprojects/gst-libav/docs/gst_plugins_cache.json b/subprojects/gst-libav/docs/gst_plugins_cache.json
index da3e728cbac7..c2bd322857a0 100644
--- a/subprojects/gst-libav/docs/gst_plugins_cache.json
+++ b/subprojects/gst-libav/docs/gst_plugins_cache.json
@@ -27140,7 +27140,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-avs:\n",
+                        "caps": "video/x-avs:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27268,7 +27268,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-dsf:\n",
+                        "caps": "audio/x-dsf:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27300,7 +27300,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-ea:\n",
+                        "caps": "video/x-ea:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27332,7 +27332,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-film_cpk:\n",
+                        "caps": "video/x-film-cpk:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27428,7 +27428,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-idcin:\n",
+                        "caps": "video/x-idcin:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27460,7 +27460,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-iff:\n",
+                        "caps": "application/x-iff:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27492,7 +27492,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-ipmovie:\n",
+                        "caps": "video/x-ipmovie:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27556,7 +27556,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-mm:\n",
+                        "caps": "application/x-mm:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27588,7 +27588,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-mmf:\n",
+                        "caps": "application/vnd.smaf:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27748,7 +27748,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-nut:\n",
+                        "caps": "application/x-nut:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27876,7 +27876,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-smk:\n",
+                        "caps": "application/x-smk:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27908,7 +27908,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-sol:\n",
+                        "caps": "application/x-sol:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -27972,7 +27972,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-vmd:\n",
+                        "caps": "application/x-vmd:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -28036,7 +28036,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-wc3movie:\n",
+                        "caps": "application/x-wc3movie:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -28068,7 +28068,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-wsaud:\n",
+                        "caps": "application/x-wsaud:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -28100,7 +28100,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-wsvqa:\n",
+                        "caps": "application/x-wsvqa:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -28132,7 +28132,7 @@
                         "presence": "sometimes"
                     },
                     "sink": {
-                        "caps": "application/x-gst-av-xwma:\n",
+                        "caps": "audio/x-xwma:\n",
                         "direction": "sink",
                         "presence": "always"
                     },
@@ -137075,8 +137075,13 @@
                 "klass": "Codec/Muxer",
                 "long-name": "libav Sega FILM / CPK muxer",
                 "pad-templates": {
+                    "audio_%%u": {
+                        "caps": "audio/x-raw:\n       channels: [ 1, 2 ]\n           rate: [ 4000, 96000 ]\n         format: S16BE\n         layout: interleaved\n",
+                        "direction": "sink",
+                        "presence": "request"
+                    },
                     "src": {
-                        "caps": "application/x-gst-av-film_cpk:\n",
+                        "caps": "video/x-film-cpk:\n",
                         "direction": "src",
                         "presence": "always"
                     },
@@ -138227,7 +138232,7 @@
                         "presence": "request"
                     },
                     "src": {
-                        "caps": "application/x-gst-av-mmf:\n",
+                        "caps": "application/vnd.smaf:\n",
                         "direction": "src",
                         "presence": "always"
                     }
@@ -138911,7 +138916,7 @@
                 "long-name": "libav NUT muxer",
                 "pad-templates": {
                     "src": {
-                        "caps": "application/x-gst-av-nut:\n",
+                        "caps": "application/x-nut:\n",
                         "direction": "src",
                         "presence": "always"
                     },
diff --git a/subprojects/gst-libav/ext/libav/gstavcodecmap.c b/subprojects/gst-libav/ext/libav/gstavcodecmap.c
index c9c0a0fa7730..9176bb1952ae 100644
--- a/subprojects/gst-libav/ext/libav/gstavcodecmap.c
+++ b/subprojects/gst-libav/ext/libav/gstavcodecmap.c
@@ -3833,6 +3833,42 @@ gst_ffmpeg_formatid_to_caps (const gchar * format_name)
     caps = gst_caps_from_string ("audio/x-brstm");
   } else if (!strcmp (format_name, "bfstm")) {
     caps = gst_caps_from_string ("audio/x-bfstm");
+  } else if (!strcmp (format_name, "avs")) {
+    caps = gst_caps_from_string ("video/x-avs");
+  } else if (!strcmp (format_name, "dsf")) {
+    caps = gst_caps_from_string ("audio/x-dsf");
+  } else if (!strcmp (format_name, "ea")) {
+    caps = gst_caps_from_string ("video/x-ea");
+  } else if (!strcmp (format_name, "film_cpk")) {
+    caps = gst_caps_from_string ("video/x-film-cpk");
+  } else if (!strcmp (format_name, "xwma")) {
+    caps = gst_caps_from_string ("audio/x-xwma");
+  } else if (!strcmp (format_name, "iff")) {
+    caps = gst_caps_from_string ("application/x-iff");
+  } else if (!strcmp (format_name, "idcin")) {
+    caps = gst_caps_new_empty_simple ("video/x-idcin");
+  } else if (!strcmp (format_name, "ipmovie")) {
+    caps = gst_caps_new_empty_simple ("video/x-ipmovie");
+  } else if (!strcmp (format_name, "mm")) {
+    caps = gst_caps_new_empty_simple ("application/x-mm");
+  } else if (!strcmp (format_name, "mmf")) {
+    caps = gst_caps_new_empty_simple ("application/vnd.smaf");
+  } else if (!strcmp (format_name, "nut")) {
+    caps = gst_caps_new_empty_simple ("application/x-nut");
+  } else if (!strcmp (format_name, "pxstr")) {
+    caps = gst_caps_new_empty_simple ("application/x-pxstr");
+  } else if (!strcmp (format_name, "smk")) {
+    caps = gst_caps_new_empty_simple ("application/x-smk");
+  } else if (!strcmp (format_name, "sol")) {
+    caps = gst_caps_new_empty_simple ("application/x-sol");
+  } else if (!strcmp (format_name, "vmd")) {
+    caps = gst_caps_new_empty_simple ("application/x-vmd");
+  } else if (!strcmp (format_name, "wc3movie")) {
+    caps = gst_caps_new_empty_simple ("application/x-wc3movie");
+  } else if (!strcmp (format_name, "wsaud")) {
+    caps = gst_caps_new_empty_simple ("application/x-wsaud");
+  } else if (!strcmp (format_name, "wsvqa")) {
+    caps = gst_caps_new_empty_simple ("application/x-wsvqa");
   } else {
     gchar *name;
 
@@ -4029,6 +4065,18 @@ gst_ffmpeg_formatid_get_codecids (const gchar * format_name,
 
     *video_codec_list = ivf_video_list;
     *audio_codec_list = ivf_audio_list;
+  } else if ((!strcmp (format_name, "film_cpk"))) {
+    static enum AVCodecID cpk_video_list[] = {
+      AV_CODEC_ID_CINEPAK,
+      AV_CODEC_ID_NONE
+    };
+    static enum AVCodecID cpk_audio_list[] = {
+      AV_CODEC_ID_PCM_S16BE,
+      AV_CODEC_ID_NONE
+    };
+
+    *video_codec_list = cpk_video_list;
+    *audio_codec_list = cpk_audio_list;
   } else if ((plugin->audio_codec != AV_CODEC_ID_NONE) ||
       (plugin->video_codec != AV_CODEC_ID_NONE)) {
     tmp_vlist[0] = plugin->video_codec;
